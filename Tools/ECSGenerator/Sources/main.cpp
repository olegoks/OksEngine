#include <filesystem>

#include <ECSGenerator.System.hpp>
#include <ECSGenerator.Component.hpp>
#include <ECSGenerator.System.hpp>
#include <ECSGenerator.Generator.hpp>

namespace ECSGenerator {



	std::shared_ptr<ParsedECSFile> ParseEcsFile(std::filesystem::path path, Resources::ResourceData& ecsFileData) {

		::Lua::Script script{ std::string{ ecsFileData.GetData<Common::Byte>(), ecsFileData.GetSize()} };

		::Lua::Context context;
		context.LoadScript(script);
		if (!context.GetGlobalAsRef("component").isNil()) {
			//std::string cxxECSCode = "//THIS FILE IS AUTOGENERATED!!!\n";
			//cxxECSCode += "#pragma once\n";
			//cxxECSCode += "\n";
			//cxxECSCode += "#include <OksEngine.ECS.Component.hpp>\n";
			//cxxECSCode += "#include <imgui.h>\n";
			//cxxECSCode += "namespace OksEngine{\n\n";

			//luabridge::LuaRef component = context.GetGlobalAsRef("component");
			//luabridge::LuaRef fields = component["fields"];
			auto parsedComponentEcsFile = ParseComponentEcsFile(path, context);
			return parsedComponentEcsFile;
			//std::string name = componentInfo.GetName();
			//std::string lowerName = componentInfo.GetLowerName();

			//cxxECSCode += GenerateComponentStructDefinition(componentInfo);

			//cxxECSCode += "\n";

			////Generate Edit function. 
			//cxxECSCode += GenerateImGuiEditFunction(componentInfo);

			////Generate Bind function. 
			//cxxECSCode += "template<>\n";
			//cxxECSCode += "inline void Bind<" + name + ">(::Lua::Context & context) {\n";
			//cxxECSCode += "\tcontext.GetGlobalNamespace()\n";
			//cxxECSCode += "\t\t.beginClass<" + name + ">(\"" + name + "\")\n";
			//for (luabridge::Iterator it(fields); !it.isNil(); ++it) {
			//	luabridge::LuaRef field = it.value();
			//	std::string type = field["type"].cast<std::string>().value();
			//	std::string fieldName = field["name"].cast<std::string>().value();
			//	if (IsBindableType(type)) {
			//		cxxECSCode += "\t\t.addProperty (\"" + fieldName + "\", &" + name + "::" + fieldName + "_)\n";
			//	}
			//}
			//cxxECSCode += "\t\t.endClass();\n";
			//cxxECSCode += "};\n\n";

			//cxxECSCode += GenerateAddFunction(componentInfo);

			
			//std::make_shared<ComponentInfo>(componentInfo);
			////Namespace OksEngine end.
			//cxxECSCode += "\n};\n";
			//return cxxECSCode;
		}

		if (!context.GetGlobalAsRef("system").isNil()) {
			//std::string cxxECSCode = "//THIS FILE IS AUTOGENERATED!!!\n";
			//cxxECSCode += "#pragma once\n";
			//cxxECSCode += "\n";
			//cxxECSCode += "#include <OksEngine.ECS.System.hpp>\n";
			//cxxECSCode += "#include <imgui.h>\n";


			/*luabridge::LuaRef system = context.GetGlobalAsRef("system");
			const SystemInfo systemInfo = CreateSystemInfo(path, system);*/

			auto parsedSystemEcsFile = ECSGenerator::ParseSystemEcsFile(path, context);

			////Generate components includes.
			//cxxECSCode += GenerateComponentIncludes(systemInfo);
			////

			//cxxECSCode += "namespace OksEngine{\n\n";


			//cxxECSCode += "\n";
			//cxxECSCode += GenerateSystemClassDefinition(systemInfo);
			//cxxECSCode += "\n";

			//cxxECSCode += GenerateSystemRunFunction(systemInfo);


			////Namespace OksEngine end.
			//cxxECSCode += "\n};\n";
			//return cxxECSCode;
			return parsedSystemEcsFile;
		}
	}
}

int main(int argc, char** argv) {



	

	OS::CommandLineParameters parameters{ argc, argv };


	OS::InitializeLogger(
		parameters.GetArgc(),
		parameters.GetArgv());

	OS::AssertMessage(argc > 1, "");
	const std::string_view workDir = parameters.GetValue("-workDir");
	std::vector<std::filesystem::path> workDirs{ workDir };
	Resources::ResourceSystem resourceSystem;
	resourceSystem.SetRoots(workDirs);

	struct ECSFileInfo {
		std::filesystem::path resourceSystemPath_;
		std::filesystem::path filesystemPath_;
	};

	std::vector<ECSFileInfo> ecsFileInfos;
	std::filesystem::path dotSystemPath_;
	const std::filesystem::path root = "Root";
	for (const auto& entry : std::filesystem::recursive_directory_iterator(workDir)) {
		if (std::filesystem::is_regular_file(entry)) {
			const bool ecsFile = entry.path().extension() == ".ecs";
			const bool dotFile = entry.path().extension() == ".dot";
			if (dotFile) {
				const std::filesystem::path name = root / entry.path().filename();
				resourceSystem.LoadResource(name);
				dotSystemPath_ = name;
			}
			if (ecsFile) {
				const std::filesystem::path name = root / entry.path().filename();
				resourceSystem.LoadResource(name);
				ecsFileInfos.push_back(ECSFileInfo{
						.resourceSystemPath_ = name,
						.filesystemPath_ = entry.path()
					});
			}
		}
	}

	auto generator = std::make_shared<ECSGenerator::CodeStructureGenerator>();

	auto projectContext = std::make_shared<ECSGenerator::ProjectContext>();

	for (const ECSFileInfo& ecsFileInfo : ecsFileInfos) {
		Resources::ResourceData resourceData = resourceSystem.GetResourceData(ecsFileInfo.resourceSystemPath_);
		auto ecsFile = ECSGenerator::ParseEcsFile(ecsFileInfo.filesystemPath_, resourceData);
		projectContext->AddEcsFile(ecsFile);


		/*const std::string autoPrefix = "auto_";
		const std::filesystem::path cxxCodeFileName = autoPrefix + ecsFileInfo.filesystemPath_.filename().replace_extension(".hpp").string();
		const std::filesystem::path cxxCodeFileFullPath = ecsFileInfo.filesystemPath_.parent_path() / cxxCodeFileName;
		OS::TextFile cxxECSCodeFile{ cxxCodeFileFullPath };
		cxxECSCodeFile.Create();
		cxxECSCodeFile << cxxCode;*/
	}



	auto files = generator->GenerateECSCXXFilesStructure(projectContext);
	auto runSystemFile = generator->GenerateRunSystemsFile(projectContext);

	ECSGenerator::SystemCallsGraphDescriptionGenerator dotGenerator;
	auto dotFile = dotGenerator.GenerateGraphText(projectContext);

	files.push_back(runSystemFile[0]);

	auto codeGenerator = std::make_shared<ECSGenerator::CodeGenerator>();

	for (auto file : files) {
		//if (file.first.filename().string() == "auto_OksEngine.CreateDriverTransform3D.hpp") {
		//	__debugbreak();
		//}
		auto codeFile = codeGenerator->GenerateCode(file.second);



		OS::TextFile cxxECSCodeFile{ file.first };
		cxxECSCodeFile.Create();
		cxxECSCodeFile << codeFile->code_.code_;
	}
	
	return 0;
}

