#version 450
//#extension GL_EXT_debug_printf : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_GOOGLE_include_directive : require
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_EXT_debug_printf : enable
#include "/common/OksEngine.Common.Math3D.glsl"
//Total Threads = Workgroups × Local Size
//
//Где:
//- Workgroups: (X, Y, Z) из vkCmdDispatch
//- Local Size: (X, Y, Z) из layout(local_size_*)
// 
// Шейдер:
//layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
// 
// Dispatch:
//vkCmdDispatch(cmd, 16, 8, 1);
//Всего потоков : 16 × 8 × 1 = 128 workgroups
//Потоков в каждой группе : 64 × 1 × 1 = 64 threads
//Общее количество потоков : 128 × 64 = 8192 threads
// Глобальный ID потока (уникальный для всего dispatch)
//uvec3 globalId = gl_GlobalInvocationID;
// = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID

// ID рабочей группы
//uvec3 workGroupId = gl_WorkGroupID;
// От 0 до параметров dispatch - 1

// Размер рабочей группы
// uvec3 workGroupSize = gl_WorkGroupSize;
// = layout(local_size_x, local_size_y, local_size_z)

// Локальный ID внутри группы
//uvec3 localId = gl_LocalInvocationID;
// От 0 до gl_WorkGroupSize - 1

// ID внутри подгруппы (для оптимизаций)
//uint subgroupId = gl_SubgroupID;
//uint laneId = gl_SubgroupInvocationID;
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;


//Основные правила std430:
//Базовые правила выравнивания:
//Скаляры (int, float, bool): выравнивание = размер типа
//
//Векторы (vec2, vec3, vec4): выравнивание = размер вектора
//
//Массивы: выравнивание = выравнивание элемента
//
//Структуры: выравнивание = максимальное выравнивание среди полей

layout(push_constant) uniform PushConstants {
    uint nodeEntitiesNumber_;
};

//POSITIONS
struct Position3D {
    vec4 position_;
};



//ROTATIONS
struct Rotaion3D {
    vec4 rotation_;
};



//ANIMATION STATE
struct AnimationState {
    uint animationIndex_;
    float animationDuration_; // Duration in ticks.
    float currentTime_; //[0..1].
};


//ANIMATION INFO

struct Position3DKey {
    float time_;
    float x_; 
    float y_; 
    float z_; 
};

struct Position3DKeys {
    Position3DKey keys_[32];
};

struct Rotation3DKey {
    float time_;
    float w_;
    float x_;
    float y_;
    float z_;
};

struct RotationKeys {
    Rotation3DKey keys_[32];
};

struct Scale3DKey {
    float time_;
    float x_;
    float y_;
    float z_;
};

struct Scale3DKeys {
    Scale3DKey keys_[32];
};
    
struct ModelNodeAnimation {
    Position3DKeys position3DKeys_;
    RotationKeys  rotationKeys_;
    Scale3DKeys  scale3DKeys_;
};

struct ModelNodeAnimations {
    ModelNodeAnimation animations_[4];
};

layout(std430, set = 0, binding = 0) buffer Positions {
    Position3D positions_[];
};

layout(std430, set = 1, binding = 0) buffer Rotations {
    Rotaion3D rotations_[];
};

layout(std430, set = 2, binding = 0) buffer AnimationStates {
    AnimationState states[];
};


layout(std430, set = 3, binding = 0) buffer AnimationsData {
    ModelNodeAnimations nodeAnimations_[];
};

layout(std430, set = 4, binding = 0) buffer ModelNodeDataEntityIds {
    uint64_t modelNodeDataEntityIds_[];
};

layout(std430, set = 5, binding = 0) buffer NodeDataEntityIdsToComponentIndices {
    uint64_t nodeDataEntityIdsToComponentIndices_[];
};


//Pointers

//  layout(buffer_reference) buffer ModelNodeAnimationPointer {
//          ModelNodeAnimation pointer;
//  };


uint binarySearchPositionKeys(in Position3DKeys keys, float currentTick) {
    uint low = 0;
    uint high = 31;

    if(IsEqual(keys.keys_[low].time_, 0.0) && IsEqual(keys.keys_[high].time_, 0.0)){
       return 1;
    }

    if(keys.keys_[low].time_ <= currentTick && currentTick  <= keys.keys_[low + 1].time_){
        return 1;
    }

    if(keys.keys_[high - 1].time_ <= currentTick && currentTick  <= keys.keys_[high].time_){
        return 31;
    }
    //uint counter = 0;
    while (low <= high) {
        uint mid = (low + high) / 2;
        float midTime = keys.keys_[mid].time_;
        
        if(midTime <= currentTick && currentTick <= keys.keys_[mid + 1].time_) {
            return mid + 1;
        }

        if (midTime < currentTick) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }

        if(low == high) {
            return high;
        }
        // counter = counter + 1;
        // if(counter > 16) {
        //     return 1;
        // }
        // ASSERT_MSG(counter < 16, "ASSERT: Infinite loop.");
        // ASSERT_MSG(low < 32, "ASSERT: Invalid low index");
        // ASSERT_MSG(high < 32, "ASSERT: Invalid high index");
    }
    
    return low; 
}

void Calculate(in ModelNodeAnimation animation, float currentTick, uint index) {
        for(uint i = 1; i < 32; i++){
            const Position3DKey previousPositionKey = animation.position3DKeys_.keys_[i - 1];
			const Position3DKey currentPositionKey = animation.position3DKeys_.keys_[i];

            if(previousPositionKey.time_ < currentTick && currentTick < currentPositionKey.time_){
                vec3 previousPosition = vec3(previousPositionKey.x_, previousPositionKey.y_, previousPositionKey.z_);
                vec3 currentPosition = vec3(currentPositionKey.x_, currentPositionKey.y_, currentPositionKey.z_);
				//currentTimeInInterval to [0 .. 1].
				//float normalizedCurrentTimeInInterval = currentTimeInInterval / (currentPositionKey.time_ - previousPositionKey.time_);//intervalTimeInTicks;
                vec3 calculatedPosition = mix(previousPosition, currentPosition, (currentTick - previousPositionKey.time_) / (currentPositionKey.time_ - previousPositionKey.time_));//normalizedCurrentTimeInInterval);
                //debugPrintfEXT("previous %f changed %f.", positions_[index].position_.x, calculatedPosition.x);
                positions_[index].position_ = vec4(calculatedPosition, 0.0);

            }

        }

        for(uint i = 1; i < 32; i++){
            const Rotation3DKey previousRotationKey = animation.rotationKeys_.keys_[i - 1];
			const Rotation3DKey currentRotationKey = animation.rotationKeys_.keys_[i];
            if(previousRotationKey.time_ < currentTick && currentTick < currentRotationKey.time_){
                vec4 previousRotation = vec4(previousRotationKey.w_, previousRotationKey.x_, previousRotationKey.y_, previousRotationKey.z_);
                vec4 currentRotation = vec4(currentRotationKey.w_, currentRotationKey.x_, currentRotationKey.y_, currentRotationKey.z_);
                //currentTimeInInterval to [0 .. 1].
				float normalizedCurrentTimeInInterval = (currentTick - previousRotationKey.time_)/*currentTimeInInterval*/ / (currentRotationKey.time_ - previousRotationKey.time_);//intervalTimeInTicks;
                
                vec4 slerp = quat_slerp(previousRotation, currentRotation, normalizedCurrentTimeInInterval);

                rotations_[index].rotation_ = slerp;

            }
        }
}

void main() {
    
    //debugPrintfEXT("%d", entitiesNumber_);
    uint index = gl_GlobalInvocationID.x;
    //debugPrintfEXT("%d", index);
    if(index < nodeEntitiesNumber_){
        AnimationState state = states[index];
        // if(state.animationIndex_ >= 4 || IsEqual(state.animationDuration_, 0.0)) {
        //     //debugPrintfEXT("Invalid animation index %d.", state.animationIndex_);
        //     return;
        // }
        //ModelNodeAnimations nodeAnimations = nodeAnimations_[index];
        
        //uint64_t modelNodeDataEntityId = modelNodeDataEntityIds_[index];
        //uint64_t modelNodeDataComponentsIndex = nodeDataEntityIdsToComponentIndices_[uint(modelNodeDataEntityIds_[index])];

        //ModelNodeAnimation animation = nodeAnimations_[uint(nodeDataEntityIdsToComponentIndices_[uint(modelNodeDataEntityIds_[index])])].animations_[state.animationIndex_];

        float currentTick = state.animationDuration_ * state.currentTime_;


        Calculate(
            nodeAnimations_[uint(nodeDataEntityIdsToComponentIndices_[uint(modelNodeDataEntityIds_[index])])].animations_[state.animationIndex_],
            state.animationDuration_ * state.currentTime_, index);

            //debugPrintfEXT(
            //"\nIndex %d \nDuration: %f\n Time factor: %f\n Current time: %f\n", 
            //    index,
            //    state.animationDuration_,
            //    state.currentTime_,
            //    currentTick);
        
        // {
        //     uint positionKeyIndex = binarySearchPositionKeys(animation.position3DKeys_, currentTick);

        //     ASSERT_FMSG_1(positionKeyIndex < 32, "ASSERT: Invalid position key index %d", positionKeyIndex);
            
        //     if(positionKeyIndex < 32){
                
            
        //     const Position3DKey previousPositionKey = animation.position3DKeys_.keys_[positionKeyIndex - 1];
		// 	const Position3DKey currentPositionKey = animation.position3DKeys_.keys_[positionKeyIndex];
        //      if(previousPositionKey.time_ < currentTick && currentTick < currentPositionKey.time_){
        //         vec3 previousPosition = vec3(previousPositionKey.x_, previousPositionKey.y_, previousPositionKey.z_);
        //         vec3 currentPosition = vec3(currentPositionKey.x_, currentPositionKey.y_, currentPositionKey.z_);

        //         vec3 calculatedPosition = mix(previousPosition, currentPosition, (currentTick - previousPositionKey.time_) / (currentPositionKey.time_ - previousPositionKey.time_));
        //         positions_[index].position_ = vec4(calculatedPosition, 0.0);
                
        //     }
        //     }
        // }

        // for(uint i = 1; i < 32; i++){
        //     const Position3DKey previousPositionKey = animation.position3DKeys_.keys_[i - 1];
		// 	const Position3DKey currentPositionKey = animation.position3DKeys_.keys_[i];
            
        //         //debugPrintfEXT(
        //         //    "\nIndex %d \nprevios: %f\n Current: %f\n Current key: %f\n", 
        //         //    index,
        //         //    previousPositionKey.time_,
        //         //    currentTick,
        //         //    currentPositionKey.time_);
            
        //     if(previousPositionKey.time_ < currentTick && currentTick < currentPositionKey.time_){
        //         vec3 previousPosition = vec3(previousPositionKey.x_, previousPositionKey.y_, previousPositionKey.z_);
        //         vec3 currentPosition = vec3(currentPositionKey.x_, currentPositionKey.y_, currentPositionKey.z_);

        //         //float intervalTimeInTicks = currentPositionKey.time_ - previousPositionKey.time_;
		// 		//float currentTimeInInterval = currentTick - previousPositionKey.time_;
		// 		//currentTimeInInterval to [0 .. 1].
		// 		//float normalizedCurrentTimeInInterval = currentTimeInInterval / (currentPositionKey.time_ - previousPositionKey.time_);//intervalTimeInTicks;
        //         vec3 calculatedPosition = mix(previousPosition, currentPosition, (currentTick - previousPositionKey.time_) / (currentPositionKey.time_ - previousPositionKey.time_));//normalizedCurrentTimeInInterval);
        //         //debugPrintfEXT("previous %f changed %f.", positions_[index].position_.x, calculatedPosition.x);
        //         positions_[index].position_ = vec4(calculatedPosition, 0.0);
        //         //positions_[index].position_.x = calculatedPosition.x;
        //         //positions_[index].position_.y = calculatedPosition.y;
        //         //positions_[index].position_.z = calculatedPosition.z;
        //         //positions_[index].position_.w = 0.0;
                
        //     }

        // }

        // for(uint i = 1; i < 32; i++){
        //     const Rotation3DKey previousRotationKey = animation.rotationKeys_.keys_[i - 1];
		// 	const Rotation3DKey currentRotationKey = animation.rotationKeys_.keys_[i];
        //     if(previousRotationKey.time_ < currentTick && currentTick < currentRotationKey.time_){
        //         vec4 previousRotation = vec4(previousRotationKey.w_, previousRotationKey.x_, previousRotationKey.y_, previousRotationKey.z_);
        //         vec4 currentRotation = vec4(currentRotationKey.w_, currentRotationKey.x_, currentRotationKey.y_, currentRotationKey.z_);

        //         //float intervalTimeInTicks = currentRotationKey.time_ - previousRotationKey.time_;
		// 		//float currentTimeInInterval = currentTick - previousRotationKey.time_;
				
        //         //currentTimeInInterval to [0 .. 1].
		// 		float normalizedCurrentTimeInInterval = (currentTick - previousRotationKey.time_)/*currentTimeInInterval*/ / (currentRotationKey.time_ - previousRotationKey.time_);//intervalTimeInTicks;
                
        //         vec4 slerp = quat_slerp(previousRotation, currentRotation, normalizedCurrentTimeInInterval);

        //         rotations_[index].rotation_ = slerp;
        //         // rotations_[index].rotation_.x = slerp.x;
        //         // rotations_[index].rotation_.y = slerp.y;
        //         // rotations_[index].rotation_.z = slerp.z;
        //         // rotations_[index].rotation_.w = slerp.w;

        //     }
        // }

				// for (Common::Index i = 1; i < nodeChannel.rotation3DValues_.size(); i++) {
				// 	const ChannelRotationKey& previousRotation3DKey = nodeChannel.rotation3DValues_[i - 1];
				// 	const ChannelRotationKey& currentRotation3DKey = nodeChannel.rotation3DValues_[i];

				// 	if (ticksSinceAnimationStart > previousRotation3DKey.time_ && ticksSinceAnimationStart < currentRotation3DKey.time_) {
				// 		const double intervalTime = currentRotation3DKey.time_ - previousRotation3DKey.time_;
				// 		const double currentTimeInInterval = ticksSinceAnimationStart - previousRotation3DKey.time_;
				// 		//currentTimeInInterval to [0 .. 1].
				// 		float normalizedCurrentTimeInInterval = currentTimeInInterval / intervalTime;
				// 		const glm::quat currentRotation3D = glm::slerp(previousRotation3DKey.rotation3D_, currentRotation3DKey.rotation3D_, normalizedCurrentTimeInInterval);
				// 		localNodeRotation3D->w_ = currentRotation3D.w;
				// 		localNodeRotation3D->x_ = currentRotation3D.x;
				// 		localNodeRotation3D->y_ = currentRotation3D.y;
				// 		localNodeRotation3D->z_ = currentRotation3D.z;
				// 		break;
				// 	}
				// }

    }

//         //TODO: binary search
// 		for (Common::Index i = 1; i < nodeChannel.position3DValues_.size(); i++) {
// 			const ChannelPositionKey& previousPosition3DKey = nodeChannel.position3DValues_[i - 1];
// 			const ChannelPositionKey& currentPosition3DKey = nodeChannel.position3DValues_[i];

// 			if (ticksSinceAnimationStart > previousPosition3DKey.time_ && ticksSinceAnimationStart < currentPosition3DKey.time_) {

// 						if (glm::distance(currentPosition3DKey.position3D_, previousPosition3DKey.position3D_) < 0.00001) {
// 							break;
// 						}

// 						const double intervalTime = currentPosition3DKey.time_ - previousPosition3DKey.time_;
// 						const double currentTimeInInterval = ticksSinceAnimationStart - previousPosition3DKey.time_;
// 						//currentTimeInInterval to [0 .. 1].
// 						float normalizedCurrentTimeInInterval = currentTimeInInterval / intervalTime;
// 						const glm::vec3 currentPosition3D = glm::mix(previousPosition3DKey.position3D_, currentPosition3DKey.position3D_, normalizedCurrentTimeInInterval);

// #pragma region Assert
// 						ASSERT_FMSG(
// 							!std::isnan(currentPosition3D.x) &&
// 							!std::isnan(currentPosition3D.y) &&
// 							!std::isnan(currentPosition3D.z), "");
// #pragma endregion

// #pragma region Assert
// 						ASSERT_FMSG(
// 							!std::isnan(currentPosition3D.x) &&
// 							!std::isnan(currentPosition3D.y) &&
// 							!std::isnan(currentPosition3D.z), "");
// #pragma endregion
// 						localNodePosition3D->x_ = currentPosition3D.x;
// 						localNodePosition3D->y_ = currentPosition3D.y;
// 						localNodePosition3D->z_ = currentPosition3D.z;
// 						break;
// 					}
// 				}

				// auto* localNodeRotation3D = std::get<LocalRotation3D*>(components);//GetComponent<LocalRotation3D>(nodeEntityId);

				// for (Common::Index i = 1; i < nodeChannel.rotation3DValues_.size(); i++) {
				// 	const ChannelRotationKey& previousRotation3DKey = nodeChannel.rotation3DValues_[i - 1];
				// 	const ChannelRotationKey& currentRotation3DKey = nodeChannel.rotation3DValues_[i];

				// 	if (ticksSinceAnimationStart > previousRotation3DKey.time_ && ticksSinceAnimationStart < currentRotation3DKey.time_) {
				// 		const double intervalTime = currentRotation3DKey.time_ - previousRotation3DKey.time_;
				// 		const double currentTimeInInterval = ticksSinceAnimationStart - previousRotation3DKey.time_;
				// 		//currentTimeInInterval to [0 .. 1].
				// 		float normalizedCurrentTimeInInterval = currentTimeInInterval / intervalTime;
				// 		const glm::quat currentRotation3D = glm::slerp(previousRotation3DKey.rotation3D_, currentRotation3DKey.rotation3D_, normalizedCurrentTimeInInterval);
				// 		localNodeRotation3D->w_ = currentRotation3D.w;
				// 		localNodeRotation3D->x_ = currentRotation3D.x;
				// 		localNodeRotation3D->y_ = currentRotation3D.y;
				// 		localNodeRotation3D->z_ = currentRotation3D.z;
				// 		break;
				// 	}
				// }

// 			auto* animationRunningState = std::get<Animation::Model::Node::RunningState*>(components);
// 			auto* childModelNodeEntities = std::get<ChildModelNodeEntities*>(components);

// 				auto* localNodeScale3D = std::get<LocalScale3D*>(components);//GetComponent<LocalScale3D>(nodeEntityId);
// 			if (animationRunningState != nullptr) {

// 				for (Common::Index i = 1; i < nodeChannel.scale3DValues_.size(); i++) {
// 					const ChannelScaleKey& previousScale3DKey = nodeChannel.scale3DValues_[i - 1];
// 					const ChannelScaleKey& currentScale3DKey = nodeChannel.scale3DValues_[i];
// 				const ModelAnimation& modelAnimation = modelAnimations0->animations_[animationRunningState->animationIndex_];
// 				//Calculate current animation tick.
// 				const Common::UInt64 msSinceAnimationStart = timeSinceEngineStart1->microseconds_ - animationInProgress0->animationStartTimeSinceEngineStart_;
// 				const float secSinceAnimationStart = msSinceAnimationStart / 1000000.0;
// 				const float ticksSinceAnimationStart = modelAnimation.ticksPerSecond_ * secSinceAnimationStart;
// 				const float animationDurationInTicks = modelAnimation.durationInTicks_;

// 					if (ticksSinceAnimationStart > previousScale3DKey.time_ && ticksSinceAnimationStart < currentScale3DKey.time_) {
// 				// Calculate current animation state from [0..1].
// 				const float currentAnimationStage = ticksSinceAnimationStart / animationDurationInTicks;

// 						if (glm::distance(currentScale3DKey.scale3D_, previousScale3DKey.scale3D_) < 0.001) {
// 							break;
// 						}

// 						const double intervalTime = currentScale3DKey.time_ - previousScale3DKey.time_;
// 						const double currentTimeInInterval = ticksSinceAnimationStart - previousScale3DKey.time_;
// 						//currentTimeInInterval to [0 .. 1].
// 						float normalizedCurrentTimeInInterval = currentTimeInInterval / intervalTime;
// 						const glm::vec3 currentScale3D = glm::slerp(previousScale3DKey.scale3D_, currentScale3DKey.scale3D_, normalizedCurrentTimeInInterval);
// #pragma region Assert
// 						ASSERT_FMSG(
// 							!std::isnan(currentScale3D.x) &&
// 							!std::isnan(currentScale3D.y) &&
// 							!std::isnan(currentScale3D.z), "");
// #pragma endregion
// 						localNodeScale3D->x_ = currentScale3D.x;
// 						localNodeScale3D->y_ = currentScale3D.y;
// 						localNodeScale3D->z_ = currentScale3D.z;
// 						break;
// 					}
// 				}
// 				animationRunningState->currentTime_ = currentAnimationStage;

// 			}
        
    //}
}