#version 450
#extension GL_EXT_debug_printf : enable
//Total Threads = Workgroups × Local Size
//
//Где:
//- Workgroups: (X, Y, Z) из vkCmdDispatch
//- Local Size: (X, Y, Z) из layout(local_size_*)
// 
// Шейдер:
//layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;
// 
// Dispatch:
//vkCmdDispatch(cmd, 16, 8, 1);
//Всего потоков : 16 × 8 × 1 = 128 workgroups
//Потоков в каждой группе : 64 × 1 × 1 = 64 threads
//Общее количество потоков : 128 × 64 = 8192 threads
// Глобальный ID потока (уникальный для всего dispatch)
//uvec3 globalId = gl_GlobalInvocationID;
// = gl_WorkGroupID * gl_WorkGroupSize + gl_LocalInvocationID

// ID рабочей группы
//uvec3 workGroupId = gl_WorkGroupID;
// От 0 до параметров dispatch - 1

// Размер рабочей группы
// uvec3 workGroupSize = gl_WorkGroupSize;
// = layout(local_size_x, local_size_y, local_size_z)

// Локальный ID внутри группы
//uvec3 localId = gl_LocalInvocationID;
// От 0 до gl_WorkGroupSize - 1

// ID внутри подгруппы (для оптимизаций)
//uint subgroupId = gl_SubgroupID;
//uint laneId = gl_SubgroupInvocationID;
layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;


//Основные правила std430:
//Базовые правила выравнивания:
//Скаляры (int, float, bool): выравнивание = размер типа
//
//Векторы (vec2, vec3, vec4): выравнивание = размер вектора
//
//Массивы: выравнивание = выравнивание элемента
//
//Структуры: выравнивание = максимальное выравнивание среди полей

layout(push_constant) uniform PushConstants {
    uint entitiesNumber_;
};

//POSITIONS
struct Position3D {
    vec3 position_;
};

layout(std430, set = 0, binding = 0) buffer Positions {
    Position3D positions_[];
};

//ANIMATION STATE
struct AnimationState {
    uint animationIndex_;
    float animationDuration_; // Duration in ticks.
    float currentTime_; //[0..1].
};

layout(std430, set = 1, binding = 0) buffer AnimationStates {
    AnimationState states[];
};

//ANIMATION INFO

struct Position3DKey {
    float time_;
    float x_; 
    float y_; 
    float z_; 
};

struct Position3DKeys {
    Position3DKey keys_[32];
};

struct Rotation3DKey {
    float time_;
    float w_;
    float x_;
    float y_;
    float z_;
};

struct RotationKeys {
    Rotation3DKey keys_[32];
};

struct Scale3DKey {
    float time_;
    float x_;
    float y_;
    float z_;
};

struct Scale3DKeys {
    Scale3DKey keys_[32];
};
    
struct ModelNodeAnimation {
    Position3DKeys position3DKeys_;
    RotationKeys  rotationKeys_;
    Scale3DKeys  scale3DKeys_;
};

struct ModelNodeAnimations {
    ModelNodeAnimation animations_[8];
};

layout(std430, set = 2, binding = 0) buffer AnimationsData {
    ModelNodeAnimations nodeAnimations_[];
};

void main() {
    
    debugPrintfEXT("started");
    // uint index = gl_GlobalInvocationID.x;
    // debugPrintfEXT("%d", index);
    // if(index < entitiesNumber_){
    //     AnimationState state = states[index];
    //     if(state.animationIndex_ >= 8) {
    //         debugPrintfEXT("Invalid animation index %d.", state.animationIndex_);
    //         return;
    //     }
    //     ModelNodeAnimations nodeAnimations = nodeAnimations_[index];
    //     ModelNodeAnimation animation = nodeAnimations.animations_[state.animationIndex_];
    //     float currentTick = state.animationDuration_ * state.currentTime_;
    //     debugPrintfEXT("float currentTick = state.animationDuration_ * state.currentTime_;");
    //     for(uint i = 1; i < 64; i++){
    //         const Position3DKey previousPositionKey = animation.position3DKeys_.keys_[i - 1];
	// 		const Position3DKey currentPositionKey = animation.position3DKeys_.keys_[i];
    //         if(previousPositionKey.time_ < currentTick && currentTick > currentPositionKey.time_){
    //             vec3 previousPosition = vec3(previousPositionKey.x_, previousPositionKey.y_, previousPositionKey.z_);
    //             vec3 currentPosition = vec3(currentPositionKey.x_, currentPositionKey.y_, currentPositionKey.z_);
    //             if(distance(previousPosition, currentPosition) < 0.00001){
    //                 break;
    //             }
    //             float intervalTimeInTicks = currentPositionKey.time_ - previousPositionKey.time_;
	// 			float currentTimeInInterval = currentTick - previousPositionKey.time_;
	// 			//currentTimeInInterval to [0 .. 1].
	// 			float normalizedCurrentTimeInInterval = currentTimeInInterval / intervalTimeInTicks;
    //             vec3 calculatedPosition = mix(previousPosition, currentPosition,normalizedCurrentTimeInInterval);
    //             debugPrintfEXT("previous %f changed %f.", positions_[index].position_.x, calculatedPosition.x);
    //             positions_[index].position_ = calculatedPosition;
                
    //         }

    //     }
    //}

//         //TODO: binary search
// 		for (Common::Index i = 1; i < nodeChannel.position3DValues_.size(); i++) {
// 			const ChannelPositionKey& previousPosition3DKey = nodeChannel.position3DValues_[i - 1];
// 			const ChannelPositionKey& currentPosition3DKey = nodeChannel.position3DValues_[i];

// 			if (ticksSinceAnimationStart > previousPosition3DKey.time_ && ticksSinceAnimationStart < currentPosition3DKey.time_) {

// 						if (glm::distance(currentPosition3DKey.position3D_, previousPosition3DKey.position3D_) < 0.00001) {
// 							break;
// 						}

// 						const double intervalTime = currentPosition3DKey.time_ - previousPosition3DKey.time_;
// 						const double currentTimeInInterval = ticksSinceAnimationStart - previousPosition3DKey.time_;
// 						//currentTimeInInterval to [0 .. 1].
// 						float normalizedCurrentTimeInInterval = currentTimeInInterval / intervalTime;
// 						const glm::vec3 currentPosition3D = glm::mix(previousPosition3DKey.position3D_, currentPosition3DKey.position3D_, normalizedCurrentTimeInInterval);

// #pragma region Assert
// 						ASSERT_FMSG(
// 							!std::isnan(currentPosition3D.x) &&
// 							!std::isnan(currentPosition3D.y) &&
// 							!std::isnan(currentPosition3D.z), "");
// #pragma endregion

// #pragma region Assert
// 						ASSERT_FMSG(
// 							!std::isnan(currentPosition3D.x) &&
// 							!std::isnan(currentPosition3D.y) &&
// 							!std::isnan(currentPosition3D.z), "");
// #pragma endregion
// 						localNodePosition3D->x_ = currentPosition3D.x;
// 						localNodePosition3D->y_ = currentPosition3D.y;
// 						localNodePosition3D->z_ = currentPosition3D.z;
// 						break;
// 					}
// 				}

				// auto* localNodeRotation3D = std::get<LocalRotation3D*>(components);//GetComponent<LocalRotation3D>(nodeEntityId);

				// for (Common::Index i = 1; i < nodeChannel.rotation3DValues_.size(); i++) {
				// 	const ChannelRotationKey& previousRotation3DKey = nodeChannel.rotation3DValues_[i - 1];
				// 	const ChannelRotationKey& currentRotation3DKey = nodeChannel.rotation3DValues_[i];

				// 	if (ticksSinceAnimationStart > previousRotation3DKey.time_ && ticksSinceAnimationStart < currentRotation3DKey.time_) {
				// 		const double intervalTime = currentRotation3DKey.time_ - previousRotation3DKey.time_;
				// 		const double currentTimeInInterval = ticksSinceAnimationStart - previousRotation3DKey.time_;
				// 		//currentTimeInInterval to [0 .. 1].
				// 		float normalizedCurrentTimeInInterval = currentTimeInInterval / intervalTime;
				// 		const glm::quat currentRotation3D = glm::slerp(previousRotation3DKey.rotation3D_, currentRotation3DKey.rotation3D_, normalizedCurrentTimeInInterval);
				// 		localNodeRotation3D->w_ = currentRotation3D.w;
				// 		localNodeRotation3D->x_ = currentRotation3D.x;
				// 		localNodeRotation3D->y_ = currentRotation3D.y;
				// 		localNodeRotation3D->z_ = currentRotation3D.z;
				// 		break;
				// 	}
				// }

// 			auto* animationRunningState = std::get<Animation::Model::Node::RunningState*>(components);
// 			auto* childModelNodeEntities = std::get<ChildModelNodeEntities*>(components);

// 				auto* localNodeScale3D = std::get<LocalScale3D*>(components);//GetComponent<LocalScale3D>(nodeEntityId);
// 			if (animationRunningState != nullptr) {

// 				for (Common::Index i = 1; i < nodeChannel.scale3DValues_.size(); i++) {
// 					const ChannelScaleKey& previousScale3DKey = nodeChannel.scale3DValues_[i - 1];
// 					const ChannelScaleKey& currentScale3DKey = nodeChannel.scale3DValues_[i];
// 				const ModelAnimation& modelAnimation = modelAnimations0->animations_[animationRunningState->animationIndex_];
// 				//Calculate current animation tick.
// 				const Common::UInt64 msSinceAnimationStart = timeSinceEngineStart1->microseconds_ - animationInProgress0->animationStartTimeSinceEngineStart_;
// 				const float secSinceAnimationStart = msSinceAnimationStart / 1000000.0;
// 				const float ticksSinceAnimationStart = modelAnimation.ticksPerSecond_ * secSinceAnimationStart;
// 				const float animationDurationInTicks = modelAnimation.durationInTicks_;

// 					if (ticksSinceAnimationStart > previousScale3DKey.time_ && ticksSinceAnimationStart < currentScale3DKey.time_) {
// 				// Calculate current animation state from [0..1].
// 				const float currentAnimationStage = ticksSinceAnimationStart / animationDurationInTicks;

// 						if (glm::distance(currentScale3DKey.scale3D_, previousScale3DKey.scale3D_) < 0.001) {
// 							break;
// 						}

// 						const double intervalTime = currentScale3DKey.time_ - previousScale3DKey.time_;
// 						const double currentTimeInInterval = ticksSinceAnimationStart - previousScale3DKey.time_;
// 						//currentTimeInInterval to [0 .. 1].
// 						float normalizedCurrentTimeInInterval = currentTimeInInterval / intervalTime;
// 						const glm::vec3 currentScale3D = glm::slerp(previousScale3DKey.scale3D_, currentScale3DKey.scale3D_, normalizedCurrentTimeInInterval);
// #pragma region Assert
// 						ASSERT_FMSG(
// 							!std::isnan(currentScale3D.x) &&
// 							!std::isnan(currentScale3D.y) &&
// 							!std::isnan(currentScale3D.z), "");
// #pragma endregion
// 						localNodeScale3D->x_ = currentScale3D.x;
// 						localNodeScale3D->y_ = currentScale3D.y;
// 						localNodeScale3D->z_ = currentScale3D.z;
// 						break;
// 					}
// 				}
// 				animationRunningState->currentTime_ = currentAnimationStage;

// 			}
        
    //}
}