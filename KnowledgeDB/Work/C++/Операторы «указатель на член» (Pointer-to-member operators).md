Операторы «_указатель на член_» позволяют описать указатель на определённый член в любом экземпляре класса. Есть два оператора «_указатель на член_», это `.*` для значений, и `->*` для указателей:

```С++
struct Test
{
    int num;
    void func() {}
};

// Обратите внимание на дополнительные "Test::" в типах указателей
int Test::*ptr_num = &Test::num;
void (Test::*ptr_func)() = &Test::func;

int main()
{
    Test t;
    Test *pt = new Test;

    // Вызовы члена функции класса:
    (t.*ptr_func)();
    (pt->*ptr_func)();

    // Присвоиение значений переменной являющейся членом данное класса
    t.*ptr_num = 1;
    pt->*ptr_num = 2;

    delete pt;
    return 0;
}
```
Эта возможность очень полезна, в частности для написания библиотек. К примеру, `Boost::Python` (библиотека для скрещивания C++ с объектами Python) использует указатели на члены для того, чтобы можно было обращаться к членам при упаковке объектов:
```С++
#include <iostream>
#include <boost/python.hpp>
using namespace boost::python;

struct World
{
    std::string msg;
    void greet() { std::cout << msg << std::endl; }
};

BOOST_PYTHON_MODULE(hello)
{
    class_<World>("World")
        .def_readwrite("msg", &World::msg)
        .def("greet", &World::greet);
}
```

При использовании указателя на член функцию, имейте в виду, что они отличаются от обычных указателей на функции. Преобразование типов между указателем на член функцию и указателем на обычную функцию не работает. Например, член функции в компиляторе Microsoft используют оптимизацию «соглашение о вызовах» называемую _thiscall_, которая кладёт параметр `this` в регистр `ecx`, в то время как обычная функция использует «соглашение о вызовах», которое передаёт все аргументы в стек.

Также, указатели на член функцию могут быть в четыре раза больше чем обычные указатели. Компилятору может понадобиться хранить адрес тела функции, смещение к правильному основанию (при множественном наследовании), индекс ещё одного смещения в _vtable_ (при виртуальном наследовании), и, может быть, даже смещение _vtable_ внутри самого объекта (для предварительного объявления классов).
```
#include <iostream>

struct A {};
struct B : virtual A {};
struct C {};
struct D : A, C {};
struct E;

int main()
{
    std::cout << sizeof(void (A::*)()) << std::endl;
    std::cout << sizeof(void (B::*)()) << std::endl;
    std::cout << sizeof(void (D::*)()) << std::endl;
    std::cout << sizeof(void (E::*)()) << std::endl;
    return 0;
}

// 32-bit MinGW GCC 5.3.0:  A = 16, B = 16, C = 16, E = 16
// 32-bit Visual C++ 2008:  A = 4,  B = 12, D = 8,  E = 16
// 32-bit Digital Mars C++: A = 4,  B = 4,  D = 4,  E = 4
```

Все указатели на члены функции в компиляторе Digital Mars одинакового размера, в связи с продуманной конструкцией, генерируемой «преобразователь» функций для применения правильных смещений вместо их хранения вместе с указателем.