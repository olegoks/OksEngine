Модель памяти представляет из себя спецификацию допустимого поведения многопоточных программ, работающих с разделяемой памятью (shared memory). Наиболее примитивной моделью является последовательная согласованность, где все инструкции из всех потоков образуют общий порядок, согласованный с порядком выполнения программы в каждом потоке.
У модели памяти есть две стороны: 
- базовые структурные аспекты, относящиеся к размещению программы в памяти.
- аспекты, связанные с параллелизмом.

Любые данные в программе на С++ состоят из объектов. В стандарте С++ объект определяется как "область памяти", хотя далее речь идет и таких свойствах объектов, как тип и время жизни. 
Некоторые объекты являются простыми значениями таких фундаментальных типов, как **int** или **float**, другие - экземплярами определенных пользовательских классов. У некоторых объектов(например, массивов, экземпляров производных классов и экземпляров классов с нестатическими данными-членами) есть подобъекты, у других - нет.
Вне зависимости от типа объект хранится в одной или нескольких *ячейках памяти*. Каждая такая ячейка - это либо объект(или подобъект) скалярного типа, например, unsigned short или MyClass*, либо последовательность соседних битовых полей. Соседние битовые поля являются различными объектами, но считаются одной ячейкой памяти.
![[Pasted image 20240528231824.png]]
Вся структура - это один объект, который состоит из нескольких подобъектов, по одному для каждого члена данных. Битовые поля *bf1* и *bf2* занимают одну ячейку памяти, а для каждого их остальных членов отведена своя ячейка. Битовое поле нулевой длины *bf3* заставляет отвести для *bf4* отдельную ячейку.
Можно сделать следующие выводы:
- Каждая переменная - объект, в том числе и переменные, являются членами других объектов.
- Каждый объект занимает по меньшей мере одну ячейку памяти.
- Переменные фундаментальных типов(**int** и **char**) занимают в точности одну ячейку памяти вне зависимости от размера, даже если являются соседними или элементами массива.
- Соседние битовые поля размещаются в одной ячейке памяти.
Если два [[Поток|потока]] обращаются к разным *ячейкам* памяти, то никаких проблем не возникает и все работает как надо. Но если [[Поток|поток]] обращается к одной и той же ячейке то необходима осторожность. Если не один потока не обновляет ячейку памяти, то все хорошо - доступ к данным для чтения не нуждается ни в защите, ни в синхронизации. Если же какой-то поток модифицирует данные, то возможно состояние [[Состояние гонки(race condition)|гонки]].
<<<<<<< HEAD
Чтобы избежать [[Состояние гонки(race condition)|гонки]], необходимо принудительно упорядочить обращение из двух потоков. Один из возможных способов такого упорядочения дают [[Мьютекс(std_mutex)|мьютексы]] - если захватывать один и тот же мьютекс перед каждым обращением, то одновременно получить доступ к [[Ячейка памяти в модели памяти С++|ячейке памяти]] сможет только один [[Поток|поток]], так что упорядочение налицо. Другой способ - воспользоваться [[Атомарные инструкции|атомарными операциями]] над теми же или другими [[Ячейка памяти в модели памяти С++|ячейками памяти]]. 
Если два обращения к одной и той же ячейке памяти из разных потоков не упорядочены и одно или оба обращения не являются атомарными и одно или оба обращения являются операциями записи, то имеет место гонка за данными , что приводит к [[Неопределенное поведение|неопределенному поведению]].
=======
Чтобы избежать [[Состояние гонки(race condition)|гонки]], необходимо принудительно упорядочить обращение из двух потоков. Один из возможных способов такого упорядочения дают [[Мьютекс(std_mutex)|мьютексы]] - если захватывать один и тот же мьютекс перед каждым обращением, то одновременно получить доступ к [[Ячейка памяти в модели памяти С++|ячейке памяти]] сможет только один [[Поток|поток]], так что упорядочение налицо. Другой способ - воспользоваться [[Атомарные операции|атомарными операциями]] над теми же или другими [[Ячейка памяти в модели памяти С++|ячейками памяти]]. 
Если два обращения к одной и той же ячейке памяти из разных потоков не упорядочены и одно или оба обращения не являются атомарными и одно или оба обращения являются операциями записи, то имеет место гонка за данными , что приводит к [[Неопределенное поведение|неопределенному поведению]].
>>>>>>> 471543714589eb34b1eb5a9a446ba0efab7f8e85
