Функциональные блоки `try` существуют для ловли исключений выброшенных при выполнении инициализационного списка конструктора. Блок вокруг списка инициализации нельзя обернуть обычным блоком `try-catch`, потому что список существует вне тела функции. Чтобы исправить это, C++ позволяет использовать `try-catch` блок в качестве тела метода:

```С++
int f() { throw 0; }

// Здесь нет способа поймать исключение выброшенное f()
struct A
{
    int a;
    A::A() : a(f()) {}
};

// Значение выброшенное из f() может быть поймано, если try-catch блок использует
// тело функции и список инициализации помещается после ключевого слова try
struct B
{
    int b;
    B::B() try : b(f())
    {}
    catch(int e)
    {}
};
```

Довольно странный синтаксис, и он может использоваться не только в конструкторах, но и в определении любых функций.