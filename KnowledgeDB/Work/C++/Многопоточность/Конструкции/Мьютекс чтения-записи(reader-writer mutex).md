Используется для доступа к структуре данных, в которой часто происходят чтения и очень редко запись/изменения данных.

Реализация данного мьютекса отсутствует в стандартной библиотеке С++, однако существует в Boost.

Итак, вместо std::mutex мы воспользуемся для синхронизации объектом boost::shared_mutex. При выполнении обновления мы будем использовать для захвата мьютекса шаблоны [[std_lock_guard|std_lock_guard]] и [[std_unique_lock|std::unique_lock]], параметризованные классом boost::shared_mutex, а не std::mutex. Они точно так же гарантируют монопольный доступ. Те же потоки, которым не нужно обновлять структуру данных, могут воспользоваться классом boost::shared_lock для получения разделяемого доступа. Применяется он так же, как std::unique_lock, но в семантике имеется одно важное отличие: несколько потоков могут одновременно получить разделяемую блокировку на один и тот же объект boost::shared_mutex. Однако если какой-то поток уже захватил разделяемую блокировку, то любой поток, который попытается захватить монопольную блокировку, будет приостановлен до тех пор, пока все прочие потоки не освободят свои блокировки. И наоборот, если какой-то поток владеет монопольной блокировкой, то никакой другой поток не сможет получить ни разделяемую, ни монопольную блокировку, пока первый поток не освободит свою
```C++
#include <map>
#include <string>
#include <mutex>
#include <boost/thread/shared_mutex.hpp>
class dns_entry;
class dns_cache {
	std::map entries;
	mutable boost::shared_mutex entry_mutex;
public: 
	dns_entry find_entry(std::string const& domain) const {
		boost::shared_lock lk(entry_mutex); // 1
		std::map::const_iterator const it= entries.find(domain);
		return (it==entries.end())?dns_entry():it->second;
	} 
	void update_or_add_entry(std::string const& domain, dns_entry const& dns_details) {
	std::lock_guard lk(entry_mutex); // 2
	entries[domain]=dns_details; 
}
};
```

В функции find_entry() используется объект boost::shared_lock<>, обеспечивающий разделяемый доступ к данным для чтения (1); следовательно, ее можно спокойно вызывать одновременно из нескольких потоков. С другой стороны, в функции update_or_add_entry() используется объект std::lock_guard<>, который обеспечивает монопольный доступ на время обновления таблицы (2), и, значит, блокируются не только другие потоки, пытающиеся одновременно выполнить update_or_add_entry(), но также потоки, вызывающие find_entry().