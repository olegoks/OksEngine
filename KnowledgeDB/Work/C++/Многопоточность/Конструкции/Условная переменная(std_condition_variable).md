Стандартная библиотека C++ предоставляется не одну, а две реализации условных переменных: std::condition_variable и std::condition_variable_any.  В обоих случаях для обеспечения синхронизации необходимо взаимодействие с мьютексом; первый класс может работать только с [[Мьютекс(std_mutex)|std::mutex]], второй – с любым классом, который отвечает минимальным требованиям к «мьютексоподобию», отсюда и суффикс _any. 

>Поскольку класс std::condition_variable_any более общий, то его использование может обойтись дороже с точки зрения объема потребляемой памяти, производительности и ресурсов операционной системы. Поэтому, если дополнительная гибкость не требуется, то лучше ограничиться классом std::condition_ variable.

[[Поток|Поток]], ожидающий работу, спить, пока не поступят данные:
```C++
std::mutex mut;
std::queue data_queue;
std::condition_variable data_cond;
void data_preparation_thread() {
	while(more_data_to_prepare()) {
		data_chunk const data=prepare_data();
		std::lock_guard lk(mut); 
		data_queue.push(data); 
		data_cond.notify_one();
	} 
} 
void data_processing_thread() { 
	while(true) { 
		std::unique_lock lk(mut); 
		data_cond.wait( 
			lk,
			[]{return !data_queue.empty();}
		); 
		data_chunk data = data_queue.front();
		data_queue.pop();
		lk.unlock(); 
		process(data); 
		if(is_last_chunk(data)) break;
	}
}
```

Итак, мы имеем очередь n, которая служит для передачи данных между двумя потоками. Когда данные будут готовы, поток, отвечающий за их подготовку, помещает данные в очередь, предварительно захватив защищающий ее мьютекс с помощью std::lock_guard. Затем он вызывает функцию-член notify_one() объекта std:: condition_variable, чтобы известить ожидающий поток (если таковой существует) p. По другую сторону забора находится поток, обрабатывающий данные. Он в самом начале захватывает мьютекс, но с помощью std:: unique_lock, а не std::lock_guard q – почему, мы скоро увидим. Затем поток вызывает функцию-член wait() объекта std:: condition_variable, передавая ей объект-блокировку и [[Лямбда-функция|лямбда-функцию]], выражающую ожидаемое условие. В данном случае простая лямбда-функция []{return !data_queue. empty();} проверяет, что очередь data_queue не пуста (вызывая ее метод empty()), то есть что в ней имеются данные для обработки. Подробнее лямбда-функции описаны в разделе A.5 приложения A. Затем функция wait() проверяет условие (вызывая переданную лямбда-функцию) и возвращает управление, если оно выполнено (то есть лямбда-функция вернула true). Если условие не выполнено (лямбда-функция вернула false), то wait() освобождает мьютекс и переводит поток в состояние ожидания. Когда условная переменная получит извещение, отправленное потоком подготовки данных с помощью notify_one(), поток обработки пробудится, вновь захватит мьютекс и еще раз проверит условие. Если условие выполнено, то wait() вернет управление, причем мьютекс в этот момент будет захвачен. Если же условие не выполнено, то поток снова освобождает мьютекс и возобновляет ожидание. Именно поэтому нам необходим std::unique_lock, а не std::lock_guard – ожидающий поток должен освобождать мьютекс, когда находится в состоянии ожидания, и захватывать его по выходе из этого состояния, а std::lock_guard такой гибкостью не обладает. Если бы мьютекс оставался захваченным в то время, когда поток обработки спит, поток подготовки данных не смог бы захватить его, чтобы поместить новые данные в очередь, а, значит, ожидаемое условие никогда не было бы выполнено.