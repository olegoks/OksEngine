Ошибочная потокобезопасная реализация [[Отложенная инициализация|отложенной инициализации]].
Cначала указатель читается без захвата [[Мьютекс(std_mutex)|мьютекса]], а захват производится, только если оказалось, что указатель равен [[nullptr|*nullptr*]]. Затем, когда мьютекс захвачен o, указатель проверяется еще раз (отсюда и слова «двойная проверка») на случай, если какой-то другой [[Поток|поток]] уже выполнил инициализацию в промежутке между первой проверкой и захватом мьютекса:

```C++
void undefined_behaviour_with_double_checked_locking() {
	if(!resource_ptr) { // 1
		std::lock_guard lk(resource_mutex);
		if(!resource_ptr) { 
			resource_ptr.reset(new some_resource); 
		} 
	} 
	resource_ptr->do_something(); 
}
```
«Печально известный» этот паттерн не без причины: он открывает возможность для крайне неприятного [[Состояние гонки(race condition)|состояния гонки]] , потому что чтение без мьютекса (1) не синхронизировано с записью в другом потоке с уже захваченным мьютексом p. Таким образом, возникает гонка, угрожающая не самому указателю, а объекту, на который он указывает; даже если один поток видит, что указатель инициализирован другим потоком, он может не увидеть вновь созданного объекта some_resource, и, следовательно, вызов do_something() q будет применен не к тому объекту, что нужно. Такого рода гонка в стандарте C++ называется [[Гонка за данными(data race)|гонкой за данными (data race)]], она отнесена к категории [[Неопределенное поведение|неопределенного поведения]].