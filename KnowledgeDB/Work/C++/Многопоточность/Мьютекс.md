У нас есть разделяемая структура данных, например связанный список из предыдущего раздела, и мы хотим защитить его от [[Гонка за данными(data race)|гонки]] и нарушения [[Инвариант|инвариантов]], к которым она приводит. Как было бы здорово, если бы мы могли пометить участки кода, в которых производятся обращения к этой структуре данных, взаимно исключающими, так что если один [[Поток|поток]] начинает выполнять такой участок, то все остальные [[Поток|потоки]] должны ждать, пока первый не завершит обработку данных. Тогда ни один [[Поток|поток]], кроме выполняющего модификацию, не смог бы увидеть нарушенный [[Инвариант|инвариант]].

>Для такого поведения используется [[Примитив синхронизации|примитив синхронизации]] мьютекс(слово mutex происходит от mutual exclusion – взаимное исключение). Перед тем, как обратиться к структуре данных, программа захватывает (lock) мьютекс, а по завершении операции с ней освобождает (unlock).

Мьютексы – наиболее общий механизм защиты данных в C++, но [[Панацея|панацеей]] они не являются; важно структурировать код так, чтобы защитить нужные данные, и избегать состояний [[Состояние гонки(race condition)|гонки]], внутренне присущих интерфейсам. С мьютексами связаны и собственные проблемы, а именно: [[Взаимоблокировка(deadlock) 1|взаимоблокировки (deadlock)]], а также защита слишком большого или слишком малого количества данных.

В C++ для создания мьютекса следует сконструировать объект типа std::mutex, для захвата мьютекса служит функция-член lock(), а для освобождения – функция-член unlock(). Однако вызывать эти функции напрямую не рекомендуется, потому что в этом случае необходимо помнить о вызове unlock() на каждом пути выхода из функции, в том числе и вследствие [[Исключение|исключений]]. Вместо этого в стандартной библиотеке имеется [[Шаблон|шаблон]] класса [[std_lock_guard|std::lock_guard]], который реализует идиому [[RAII]] – захватывает мьютекс в [[Конструктор|конструкторе]] и освобождает в [[Деструктор||деструкторе]], – гарантируя тем самым, что захваченный мьютекс обязательно будет освобожден.
