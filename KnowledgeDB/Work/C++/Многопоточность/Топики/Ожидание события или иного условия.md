Если один поток хочет дождаться, когда другой завершит некую операцию, то может поступить несколькими способами. 
- Во-первых, он может просто проверять разделяемый флаг (защищенный [[Мьютекс(std_mutex)|мьютексом]]), полагая, что второй поток поднимет этот флаг, когда завершит свою операцию. Это расточительно по двум причинам: на опрос флага уходит процессорное время, и мьютекс, захваченный ожидающим потоком, не может быть захвачен никаким другим потоком. То и другое работает против ожидающего потока, поскольку ограничивает ресурсы, доступные потоку, которого он так ждет, и даже не дает ему возможность поднять флаг, когда работа будет завершена. Это решение сродни бодрствованию всю ночь, скрашиваемому разговорами с машинистом: он вынужден вести поезд медленнее, потому что вы его постоянно отвлекаете, и, значит, до пункта назначения вы доберетесь позже. Вот и ожидающий поток потребляет ресурсы, которые пригодились бы другим потокам, в результате чего ждет дольше, чем необходимо.
- Второй вариант – заставить ожидающий [[Поток|поток]] спать между проверками с помощью функции std::this_thread::sleep_for():
```C++
bool flag;
std::mutex m;
void wait_for_flag() { 
	std::unique_lock lk(m); 
	while(!flag) { lk.unlock();
std::this_thread::sleep_for(std::chrono::milliseconds(100));
	lk.lock(); }
}
```

В этом цикле функция освобождает мьютекс перед тем, как заснуть o, и снова захватывает его, проснувшись, оставляя другому потоку шанс захватить мьютекс и поднять флаг. Это уже лучше, потому что во время сна поток не расходует процессорное время. Но трудно выбрать подходящий промежуток времени. Если он слишком короткий, то поток все равно впустую тратит время на проверку; если слишком длинный – то поток будет спать и после того, как ожидание завершилось, то есть появляется ненужная задержка. Редко бывает так, что слишком длительный сон прямо влияет на работу программу, но в динамичной игре это может привести к пропуску кадров, а в приложении реального времени – к исчерпанию выделенного временного кванта. 
- Третий – и наиболее предпочтительный – способ состоит в том, чтобы воспользоваться средствами из стандартной библиотеки C++, которые позволяют потоку ждать события. Самый простой механизм ожидания события, возникающего в другом потоке (например, появления нового задания в упоминавшемся выше конвейере), дают [[Условная переменная(std_condition_variable)|условные переменные]]. Концептуально условная переменная ассоциирована с каким-то событием или иным условием, причем один или несколько потоков могут ждать, когда это условие окажется выполненным. Если некоторый поток решит, что условие выполнено, он может известить об этом один или несколько [[Поток|потоков]], ожидающих [[Условная переменная(std_condition_variable)|условную переменную]], в результате чего они возобновят работу.