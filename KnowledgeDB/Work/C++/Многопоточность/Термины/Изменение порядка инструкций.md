Под этим определением подразумевается, что некоторые части системы могут взять [[Инструкция процессора|инструкции]], выполняемые вашим приложением, и переставить их. То есть они могут взять операцию записи и выполнить ее после чтения, хотя изначальный порядок был другим, могут взять две операции записи разных переменных и также изменить порядок выполнения. Например: одно ядро считает, что значение переменной равно 7, а другое ядро еще не заметило изменение значения и считает, что оно все еще равно 6. Такое различие информации, хранящейся в ядрах, может привести к проблемам. Таким образом, [[Атомарные инструкции|атомарность]], [[Эксклюзивный доступ к памяти|эксклюзивность]] и переупорядочивание памяти, не связаны между собой. Атомарность не гарантирует эксклюзивность, а эксклюзивность не гарантирует выполнение инструкций в определенном порядке. Различные части системы: процессор, компилятор, контроллер памяти могут изменять порядок операций. И это сделано не для того, чтобы проверить, на сколько вы хороший разработчик. Это оптимизация.

**Пример 1**:
Предположим, у вас есть цикл, считывающий значения из массива, но есть некоторое значение, к которому вы обращаетесь много раз.
```C++
int sum = 0;
int p = get_pivot();
for(int i = 0; i < p; ++i){
	sum += data[i] * data[p];
}
```
Для компилятора было бы разумно вынести обращение к этому значению за пределы цикла, чтобы считать его только один раз и переиспользовать внутри цикла. Компилятор делает что-то подобное постоянно. Обычно мы не против, ведь это ускоряет наш код.

**Пример 2**:
Следующий пример — это векторизация. Сегодня множество компиляторов автоматически генерируют другую версию цикла, которая использует [[Векторные интрукции|векторные инструкции]] и векторные регистры в вашем процессоре. Если кратко, вместо того, чтобы считывать значение сначала из первого массива, потом записывать его во второй, потом считывать очередное значение из первого, потом опять записывать его во второй, вы считываете 4 значения из первого массива и записываете их во второй. Это своего рода изменение порядка считываний и записи. 

```C++
// original code
for(int i =0; i < n; ++i){
	dst[i] = src[i];
}

//vectorized (and therefore reordered):
for(int i = 0; i < n; i+=16){
	auto val = _mm_stream_load_si128((__m128i*)&src[i]);
	_mm_stream_si128((__m128i*)&dst[i], val);
}
```

**Пример 3**:
Еще один пример — это отбрасывание считываний. Компилятор может решить, что нет смысла считывать некоторое значение дважды, если можно считать его только один раз и сохранить результат. ^70c3ab

```C++
// original code
if(arg1 == 0) throw new ArgumentException();
int val = arg2 + 1;
val += arg1;

//optimized (reordered) code:
int tmp = arg1;
if (tmp == 0) throw new ArgumentException();
int val = arg2 + 1; 
val += tmp;
```

Процессоры переставляют местами некоторые операции из-за [[Конвеер процессора|конвейерной обработки]].
![[Pasted image 20240603190649.png]]Так происходит у процессоров с MIPS-архитектурой сорокалетней давности. На современных процессорах Intel может быть 20 подобных фаз. Одна инструкция перемещается между фазами, пока другая инструкция находится в первой фазе, еще одна инструкция — во второй и так далее. То есть множество инструкций находятся в разных фазах в одно и то же время. **И результатом может быть изменение порядка: первая инструкция, записывающая значение в память, выполнится после третьей инструкции, считывающей значение из памяти, хотя изначальный порядок был другим**. Наличие нескольких стадий в выполнении инструкций может привести к изменению порядка этих инструкций, если только вы не скажете компьютеру, что не допускаете подобные перестановки и хотите, чтобы инструкции выполнялись в изначальном порядке.

Последняя причина оптимизаций связана с задержками памяти; в основном, со временем, которое требуется для распространения изменений на всю систему памяти.
![[Pasted image 20240603192453.png]]
В современных процессорах Intel, например, у каждого ядра есть свой буфер — небольшая очередь, которая хранит последние операции записи. Этот буфер сбрасывается в память в фоновом режиме. То есть, если процессору пришла инструкция «Запиши Х в память» и он ответил «Сделано», на самом деле это может быть не так, и значение Х может находиться в буфере, который не видят другие ядра процессора. Буфер сбрасывается в память асинхронно. Даже после выгрузки буфера значение должно пройти несколько этапов кэширования, что также происходит довольно медленно.

Как понять, какие перестановки инструкций допустимы и что именно процессор будет считать верной оптимизацией? **Есть одно правило, которое гласит, что необходимо соблюдать зависимости данных**. Например, если в одном потоке сначала переменной Х присваивается значение 1, затем происходит считывание Х, последняя операция должна вернуть 1. Или если в потоке сначала какое-то значение присваивается переменной Х, затем какое-то значение присваивается переменной Y, и после этого происходит вычисление суммы Х и Y. Нет гарантий, какое присвоение произойдет раньше, но обе операции должны произойти до того, как X и Y будут считаны из памяти снова.
Но как только появляются несколько ядер, которые обращаются к несвязанным переменным, не соблюдается почти ничего. Например, на ARM-процессорах, которые находятся внутри большинства смартфонов, процессору, согласно спецификации, разрешено как угодно переставлять операции чтения и записи.
![[Pasted image 20240603192349.png]]То есть процессору разрешено переставлять две операции чтения, чтение и запись, запись и чтение, и две операции записи между собой. Единственная причина, по которой мы не видим подобное каждый день — мы редко используем эти процессоры. Чаще мы используем более надежную модель, которой на данный момент придерживается Intel. В ней единственная разрешенная перестановка — запись после чтения. То есть, если у вас есть две операции — запись, затем чтение, процессор может выполнить чтение раньше. И это единственное, что процессор Intel позволяет оптимизировать. 

**Пример 1:**
Допустим, у нас есть небольшой фрагмент C или C++ кода(часть кода из [[Блокировка с двойной проверкой (Double-Checked Locking)]]), в котором первый [[Поток|поток]] сравнивает с `null` глобальную переменную, и если она действительно равна `null`, использует ее, а в то же время второй поток создает новый объект и кладет его в глобальную переменную.
![[Pasted image 20240603192841.png]]Операции в коде выглядят [[Атомарные инструкции|атомарными]], и чтение из памяти, и запись в память происходит только один раз. Казалось бы, здесь нет многократных изменений, которые могут помешать друг другу, поэтому код должен работать. Однако, на ARM, например, он работать не будет, так как [[Конструктор|конструктор]] во втором потоке также производит запись в память (инициализирует объект). Эта операция записи может произойти после записи значения в глобальную переменную. Тогда первый поток увидит частично инициализированную переменную, то есть переменную, создание которой еще не закончено. При этом код выглядит довольно чисто. На Intel данный код будет работать, потому что там, в отличие от ARM, не разрешены перестановки операций записи.

**Пример 2:**
Второй пример — первый поток обновляет переменную, затем присваивает флагу значение `true`, а второй поток проверяет значение флага и, если оно равно `true`, использует переменную.
![[Pasted image 20240603193533.png]]
Операции записи значений переменной и флага могут быть переставлены. Если это произойдет, второй поток увидит, что флаг установлен, но, при этом переменная еще не инициализирована. Более того, теоретически, на некоторых платформах, может быть изменен порядок выполнения операций чтения во втором потоке. То есть вполне возможная ситуация — сначала считывается значение переменной, затем проверяется флаг. И, как результат, мы попытаемся использовать неинициализированную переменную. В общем, данный пример не будет работать на платформах с  моделью памяти, разрешающей разного вида перестановки, даже если все операции в примере [[Атомарные инструкции|атомарные]] и [[Эксклюзивный доступ к памяти|эксклюзивные]] (нет двух потоков, модифицирующих одну и ту же часть памяти).

Для предотвращения изменения порядка инструкций применяются [[Барьеры памяти|барьеры памяти]].
