Когда мы говорим, что [[Инструкция процессора|инструкция]] атомарна, мы имеем в виду, что она не может быть прервана. Это означает, что во время выполнения операции не может произойти переключение потока, операция не может частично завершиться. На оборудовании с 64-битными процессорами Intel можно быть уверенными, что операции чтения и записи значений меньше 64 бит являются атомарными. Эти операции не могут быть прерваны и не могут частично завершиться. Проблема в том, что большинство на первый взгляд простых операций, которые мы пишем на языках высокого уровня, на самом деле не являются атомарными. Очевидный пример, с которым многие из вас наверняка знакомы — увеличение значения на единицу. 
На [[C++]], компилятор сгенерирует код наподобие такого:
![[Pasted image 20240603182844.png]]
Это последовательность инструкций, выполняющая считывание из памяти, добавление единицы и запись обратно в память. Каждая операция из этой последовательности атомарная, а вся последовательность, очевидно, не является атомарной операцией. Важно понимать, что многие операции кажутся атомарными на языках высокого уровня, но на самом деле таковыми не являются. В этом можно убедиться, посмотрев на сгенерированный машинный код.
Наличие атомарной [[Инструкция процессора|инструкции]] не гарантирует [[Эксклюзивный доступ к памяти|эксклюзивный доступ к памяти]]. Если у вас есть два ядра, выполняющих увеличение значения на единицу, в итоге вы можете столкнуться с ситуацией, когда значение увеличится только один раз. Оба ядра считают ноль из памяти и запишут в свой [[Кэш процессора|кэш]], оба ядра сохранят запись об увеличении значения в своем буфере, но только одна из этих записей победит и, в конечном итоге, будет сохранена в памяти.
![[Pasted image 20240603182940.png]]Так что атомарность инструкции **не гарантирует** [[Эксклюзивный доступ к памяти/эксклюзивный доступ к памяти]]. 
>Ошибочно полагать, что атомарные инструкции всегда потокобезопасны. 

Атомарность — это одно, а [[Эксклюзивный доступ к памяти|эксклюзивность]] — другое. Но мы можем запросить [[Эксклюзивный доступ к памяти|эксклюзивный доступ к памяти]]
```C++
static int v1 = 0;
static std::atomic<int> v2{ 0 };

int add_v1() {
    return ++v1;
    /* Generated x86-64 assembly:
        mov     eax, DWORD PTR v1[rip]
        add     eax, 1
        mov     DWORD PTR v1[rip], eax
    */
}

int add_v2() {
    return v2.fetch_add(1);
    /* Generated x86-64 assembly:
        mov     eax, 1
        lock xadd       DWORD PTR _ZL2v2[rip], eax
    */
}
```