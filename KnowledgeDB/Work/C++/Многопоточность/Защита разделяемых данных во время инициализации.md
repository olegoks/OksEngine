Предположим, имеется разделяемый ресурс для которого необходима [[Отложенная инициализация|отложенная инициализация]]. Всякая операция, нуждающаяся в ресурсе, сначала проверяет, инициализирован ли он, и, если нет, выполняет инициализацию:

```C++
std::shared_ptr resource_ptr; 
void foo() { 
	if(!resource_ptr) { 
		resource_ptr.reset(new some_resource); 
	} 
	resource_ptr->do_something();
}
```

Многопоточная наивная реализация:
```C++
std::shared_ptr resource_ptr;
std::mutex resource_mutex;
void foo() { 
	std::unique_lock lk(resource_mutex);
	if(!resource_ptr) { 
		resource_ptr.reset(new some_resource);
	} 
	lk.unlock(); 
	resource_ptr->do_something();
}
```
Данное решение может привести к ненужной сериализации использующих ресурс потоков. Дело в том, что каждый поток должен ждать освобождения [[Мьютекс|мьютекса]], чтобы проверить, был ли ресурс уже инициализирован.